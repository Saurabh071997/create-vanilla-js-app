# Create Vanilla JS App

<img alt="img" align="right" src="./src/js_img.gif" width="20%"/>

 **Create Vanilla JS : Starter Pack** is a webpack configured to create modern Javascript web applications.


## **Installation**
You can use the configured webpack by either cloning the repository or through `degit`. I personally prefer to use [degit](https://github.com/Rich-Harris/degit).
   
### **degit**

degit makes copies of git repositories. When you run degit some-user/some-repo, it will find the latest commit on https://github.com/some-user/some-repo and download the associated tar file

> degit installtaion

```bash
npm install -g degit
```
> degit Usage for this repo

Follow the below instructions to use this webpack
```
degit Saurabh071997/create-vanilla-js-app#dev my-app-name
```
If you are trying to clone this repo in an already existing git repository you might face an issue stating
```
! destination directory is not empty, aborting. Use --force to override
```
for such a case you can use
```
degit --force Saurabh071997/create-vanilla-js-app#dev my-app-name
```

So the steps follows as
```
degit Saurabh071997/create-vanilla-js-app#dev my-app-name
cd my-app-name
npm i


# to start your application in localhost:3000
npm run start 
```
You can read more about degit and its usage here ðŸ‘‰  [degit](https://github.com/Rich-Harris/degit)

<br/>

## **What's Included**
This webpack covers a wide variety of all the necessary dependencies you might require in your application
- babel
- css support
- assets (images)
- eslint support
- code-splitting
- caching 
- html optimisation via html-webpack

<br/><br/>

>## `babel`
Babel loader is used to convert code written in modern flavors and supersets of JavaScript into plain old JavaScript code supported by older browsers. Thanks to Babel loader we can enjoy new JavaScript syntax and write our code using EcmaScript 2015 and even JSX (React).

Read more about [babel-loader](https://www.npmjs.com/package/babel-loader), [babel-loader: webpack](https://webpack.js.org/loaders/babel-loader/), [@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env)

<br/><br/>

>## `css-loader & style-loader`
Webpack by itself only knows javascript, so when we want it to pack any other type of resources like .css or .scss or .ts, webpack needs help in order to compile and bundle those non-javascript types of resources.

css-loader is the npm module that would help webpack to collect CSS from all the css files referenced in your application and put it into a string.
And then style-loader would take the output string generated by the above css-loader and put it inside the &lt;style&gt; tags in the `index.html` file.

Read more about [css-loader](https://www.npmjs.com/package/css-loader), [style-loader](https://www.npmjs.com/package/style-loader)
Read more on [css-loader in webpack](https://webpack.js.org/loaders/css-loader/)

<br/><br/>

>## `Loading Images`
So now we're pulling in our CSS, but what about our images like backgrounds and icons? As of webpack 5, using the built-in [Asset Modules](https://webpack.js.org/guides/asset-management/#loading-images) we can easily incorporate those in our system as wel

<br/><br/>

>## `Eslint support`
ESLint is a tool for identifying and reporting on patterns found in ECMAScript/JavaScript code, with the goal of making code more consistent and avoiding bugs.

Currently the webpack checks for unused variables and imports globally and locally.

However you can modify the eslint rules as per your application requirements from `/src/.eslintrc.js` file. 

Read more about [eslint](https://www.npmjs.com/package/eslint).

<br/><br/>

>## `Code-Splitting`
Code splitting is one of the most compelling features of webpack. This feature allows you to split your code into various bundles which can then be loaded on demand or in parallel. It can be used to achieve smaller bundles and control resource load prioritization which, if used correctly, can have a major impact on load time.

Read more about [code-splitting](https://webpack.js.org/guides/code-splitting/)

<br/><br/>

>## `Caching`
So we're using webpack to bundle our modular application which yields a deployable /dist directory. Once the contents of /dist have been deployed to a server, clients (typically browsers) will hit that server to grab the site and its assets. The last step can be time consuming, which is why browsers use a technique called caching. This allows sites to load faster with less unnecessary network traffic.

Read more about [caching](https://webpack.js.org/guides/caching/#output-filenames)

<br/><br/>

>## `html optimisation`
The `HtmlWebpackPlugin` simplifies creation of HTML files to serve your webpack bundles. This is especially useful for webpack bundles that include a hash in the filename which changes every compilation.

The plugin will generate an HTML5 file for you that includes all your webpack bundles in the body using script tags. 

Read more about [html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin)

<br/><br/>

## Few Key Points
- You can modify the app title from `html-webpack-plugin` in `webpack.commom.js` file.
- Similarly the favicon is managed with `favicon-webpack-plugin`
- To use `async/await` functionalities follow the below steps:
```
npm i regenerator-runtime
```
```
// CommonJS
require("regenerator-runtime/runtime");
 
// ECMAScript 2015
import "regenerator-runtime/runtime.js";
```

